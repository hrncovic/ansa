//
// Generated file, do not edit! Created by opp_msgc 4.2 from ansa/isis/ISISMessage.msg.
//

#ifndef _ISISMESSAGE_M_H_
#define _ISISMESSAGE_M_H_

#include <omnetpp.h>

// opp_msgc version check
#define MSGC_VERSION 0x0402
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of opp_msgc: 'make clean' should help.
#endif

// cplusplus {{
typedef struct NSAP_t
    {
        unsigned char AreaAddr[3];
        unsigned char sysID[6];
        unsigned char NSEL;
        
    } NSAP_t;
    
    typedef struct TLV_t
    {
        unsigned char type;
        unsigned char length;
        unsigned char value[];
    } TLV_t;
// }}



/**
 * Enum generated from <tt>ansa/isis/ISISMessage.msg</tt> by opp_msgc.
 * <pre>
 * enum PDU_Type
 * {
 * 	LAN_L1_HELLO = 15;
 * 	LAN_L2_HELLO = 16;
 * 	PTP_HELLO = 17;
 * 	L1_LSP = 18;
 * 	L2_LSP = 20;
 * 	L1_CSNP = 24;
 * 	L2_CSNP = 25;
 * 	L1_PSNP = 26;
 * 	L2_PSNP = 27;
 * };
 * </pre>
 */
enum PDU_Type {
    LAN_L1_HELLO = 15,
    LAN_L2_HELLO = 16,
    PTP_HELLO = 17,
    L1_LSP = 18,
    L2_LSP = 20,
    L1_CSNP = 24,
    L2_CSNP = 25,
    L1_PSNP = 26,
    L2_PSNP = 27
};

/**
 * Enum generated from <tt>ansa/isis/ISISMessage.msg</tt> by opp_msgc.
 * <pre>
 * enum curcuitTypes
 * {
 * 	RESERVED = 0;		
 * 	L1 = 1;				
 * 	L2 = 2;				
 * 	L1L2 = 3;			
 * }
 * </pre>
 */
enum curcuitTypes {
    RESERVED = 0,
    L1 = 1,
    L2 = 2,
    L1L2 = 3
};

/**
 * Class generated from <tt>ansa/isis/ISISMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet ISISMessage extends cPacket
 * {
 *     unsigned char IRPD = 0x83; 			
 *     unsigned char length; 				
 *     unsigned char version = 0x01;		
 *     unsigned char idLength = 0x00;		
 *     unsigned char type enum(PDU_Type);	
 *     unsigned char version2 = 0x01;		
 *     unsigned char reserved = 0x00;		
 *     unsigned char maxAreas = 0x00;		
 * };
 * </pre>
 */
class ISISMessage : public ::cPacket
{
  protected:
    unsigned char IRPD_var;
    unsigned char length_var;
    unsigned char version_var;
    unsigned char idLength_var;
    unsigned char type_var;
    unsigned char version2_var;
    unsigned char reserved_var;
    unsigned char maxAreas_var;

  private:
    void copy(const ISISMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ISISMessage&);

  public:
    ISISMessage(const char *name=NULL, int kind=0);
    ISISMessage(const ISISMessage& other);
    virtual ~ISISMessage();
    ISISMessage& operator=(const ISISMessage& other);
    virtual ISISMessage *dup() const {return new ISISMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned char getIRPD() const;
    virtual void setIRPD(unsigned char IRPD);
    virtual unsigned char getLength() const;
    virtual void setLength(unsigned char length);
    virtual unsigned char getVersion() const;
    virtual void setVersion(unsigned char version);
    virtual unsigned char getIdLength() const;
    virtual void setIdLength(unsigned char idLength);
    virtual unsigned char getType() const;
    virtual void setType(unsigned char type);
    virtual unsigned char getVersion2() const;
    virtual void setVersion2(unsigned char version2);
    virtual unsigned char getReserved() const;
    virtual void setReserved(unsigned char reserved);
    virtual unsigned char getMaxAreas() const;
    virtual void setMaxAreas(unsigned char maxAreas);
};

inline void doPacking(cCommBuffer *b, ISISMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, ISISMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>ansa/isis/ISISMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet ISISL1HelloPacket extends ISISMessage
 * {
 * 	type = LAN_L1_HELLO;							
 * 	unsigned char curcuitType enum(curcuitTypes);	
 * 	unsigned char sourceID[6];						
 * 	unsigned short holdTime;						
 * 	unsigned short pduLength;						
 * 	unsigned char priority = 64;					
 * 	unsigned char lanID[7];							
 * 	TLV_t TLV[];									
 * }
 * </pre>
 */
class ISISL1HelloPacket : public ::ISISMessage
{
  protected:
    unsigned char curcuitType_var;
    unsigned char sourceID_var[6];
    unsigned short holdTime_var;
    unsigned short pduLength_var;
    unsigned char priority_var;
    unsigned char lanID_var[7];
    TLV_t *TLV_var; // array ptr
    unsigned int TLV_arraysize;

  private:
    void copy(const ISISL1HelloPacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ISISL1HelloPacket&);

  public:
    ISISL1HelloPacket(const char *name=NULL, int kind=0);
    ISISL1HelloPacket(const ISISL1HelloPacket& other);
    virtual ~ISISL1HelloPacket();
    ISISL1HelloPacket& operator=(const ISISL1HelloPacket& other);
    virtual ISISL1HelloPacket *dup() const {return new ISISL1HelloPacket(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned char getCurcuitType() const;
    virtual void setCurcuitType(unsigned char curcuitType);
    virtual unsigned int getSourceIDArraySize() const;
    virtual unsigned char getSourceID(unsigned int k) const;
    virtual void setSourceID(unsigned int k, unsigned char sourceID);
    virtual unsigned short getHoldTime() const;
    virtual void setHoldTime(unsigned short holdTime);
    virtual unsigned short getPduLength() const;
    virtual void setPduLength(unsigned short pduLength);
    virtual unsigned char getPriority() const;
    virtual void setPriority(unsigned char priority);
    virtual unsigned int getLanIDArraySize() const;
    virtual unsigned char getLanID(unsigned int k) const;
    virtual void setLanID(unsigned int k, unsigned char lanID);
    virtual void setTLVArraySize(unsigned int size);
    virtual unsigned int getTLVArraySize() const;
    virtual TLV_t& getTLV(unsigned int k);
    virtual const TLV_t& getTLV(unsigned int k) const {return const_cast<ISISL1HelloPacket*>(this)->getTLV(k);}
    virtual void setTLV(unsigned int k, const TLV_t& TLV);
};

inline void doPacking(cCommBuffer *b, ISISL1HelloPacket& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, ISISL1HelloPacket& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>ansa/isis/ISISMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet ISISL2HelloPacket extends ISISL1HelloPacket
 * {
 * 	type = LAN_L2_HELLO;							
 * }
 * </pre>
 */
class ISISL2HelloPacket : public ::ISISL1HelloPacket
{
  protected:

  private:
    void copy(const ISISL2HelloPacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ISISL2HelloPacket&);

  public:
    ISISL2HelloPacket(const char *name=NULL, int kind=0);
    ISISL2HelloPacket(const ISISL2HelloPacket& other);
    virtual ~ISISL2HelloPacket();
    ISISL2HelloPacket& operator=(const ISISL2HelloPacket& other);
    virtual ISISL2HelloPacket *dup() const {return new ISISL2HelloPacket(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, ISISL2HelloPacket& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, ISISL2HelloPacket& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>ansa/isis/ISISMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet ISISPTPHelloPacket extends ISISMessage
 * {
 *     type = PTP_HELLO;								
 * 	unsigned char curcuitType enum(curcuitTypes);	
 * 	unsigned char sourceID[6];						
 * 	unsigned short holdTime;						
 * 	unsigned short pduLength;						
 * 	unsigned char localCircuitID;					
 * 	TLV_t TLV[];									
 * }
 * </pre>
 */
class ISISPTPHelloPacket : public ::ISISMessage
{
  protected:
    unsigned char curcuitType_var;
    unsigned char sourceID_var[6];
    unsigned short holdTime_var;
    unsigned short pduLength_var;
    unsigned char localCircuitID_var;
    TLV_t *TLV_var; // array ptr
    unsigned int TLV_arraysize;

  private:
    void copy(const ISISPTPHelloPacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ISISPTPHelloPacket&);

  public:
    ISISPTPHelloPacket(const char *name=NULL, int kind=0);
    ISISPTPHelloPacket(const ISISPTPHelloPacket& other);
    virtual ~ISISPTPHelloPacket();
    ISISPTPHelloPacket& operator=(const ISISPTPHelloPacket& other);
    virtual ISISPTPHelloPacket *dup() const {return new ISISPTPHelloPacket(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned char getCurcuitType() const;
    virtual void setCurcuitType(unsigned char curcuitType);
    virtual unsigned int getSourceIDArraySize() const;
    virtual unsigned char getSourceID(unsigned int k) const;
    virtual void setSourceID(unsigned int k, unsigned char sourceID);
    virtual unsigned short getHoldTime() const;
    virtual void setHoldTime(unsigned short holdTime);
    virtual unsigned short getPduLength() const;
    virtual void setPduLength(unsigned short pduLength);
    virtual unsigned char getLocalCircuitID() const;
    virtual void setLocalCircuitID(unsigned char localCircuitID);
    virtual void setTLVArraySize(unsigned int size);
    virtual unsigned int getTLVArraySize() const;
    virtual TLV_t& getTLV(unsigned int k);
    virtual const TLV_t& getTLV(unsigned int k) const {return const_cast<ISISPTPHelloPacket*>(this)->getTLV(k);}
    virtual void setTLV(unsigned int k, const TLV_t& TLV);
};

inline void doPacking(cCommBuffer *b, ISISPTPHelloPacket& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, ISISPTPHelloPacket& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>ansa/isis/ISISMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet ISISLSPL1Packet extends ISISMessage
 * {
 * 	type = L1_LSP;
 * 	unsigned short pduLength;						
 * 	unsigned short remLifeTime = 1200;				
 * 	unsigned char lspID[8];							
 * 	unsigned long seqNumber = 0;					
 * 	unsigned short checksum;						
 * 	unsigned char PATTLSPDBOLIS = 0x01;				
 * 													
 * 													
 * 													
 * 													
 * 	TLV_t TLV[];									
 * }
 * </pre>
 */
class ISISLSPL1Packet : public ::ISISMessage
{
  protected:
    unsigned short pduLength_var;
    unsigned short remLifeTime_var;
    unsigned char lspID_var[8];
    unsigned long seqNumber_var;
    unsigned short checksum_var;
    unsigned char PATTLSPDBOLIS_var;
    TLV_t *TLV_var; // array ptr
    unsigned int TLV_arraysize;

  private:
    void copy(const ISISLSPL1Packet& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ISISLSPL1Packet&);

  public:
    ISISLSPL1Packet(const char *name=NULL, int kind=0);
    ISISLSPL1Packet(const ISISLSPL1Packet& other);
    virtual ~ISISLSPL1Packet();
    ISISLSPL1Packet& operator=(const ISISLSPL1Packet& other);
    virtual ISISLSPL1Packet *dup() const {return new ISISLSPL1Packet(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned short getPduLength() const;
    virtual void setPduLength(unsigned short pduLength);
    virtual unsigned short getRemLifeTime() const;
    virtual void setRemLifeTime(unsigned short remLifeTime);
    virtual unsigned int getLspIDArraySize() const;
    virtual unsigned char getLspID(unsigned int k) const;
    virtual void setLspID(unsigned int k, unsigned char lspID);
    virtual unsigned long getSeqNumber() const;
    virtual void setSeqNumber(unsigned long seqNumber);
    virtual unsigned short getChecksum() const;
    virtual void setChecksum(unsigned short checksum);
    virtual unsigned char getPATTLSPDBOLIS() const;
    virtual void setPATTLSPDBOLIS(unsigned char PATTLSPDBOLIS);
    virtual void setTLVArraySize(unsigned int size);
    virtual unsigned int getTLVArraySize() const;
    virtual TLV_t& getTLV(unsigned int k);
    virtual const TLV_t& getTLV(unsigned int k) const {return const_cast<ISISLSPL1Packet*>(this)->getTLV(k);}
    virtual void setTLV(unsigned int k, const TLV_t& TLV);
};

inline void doPacking(cCommBuffer *b, ISISLSPL1Packet& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, ISISLSPL1Packet& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>ansa/isis/ISISMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet ISISLSPL2Packet extends ISISLSPL1Packet
 * {
 * 	type = L2_LSP;
 * }
 * </pre>
 */
class ISISLSPL2Packet : public ::ISISLSPL1Packet
{
  protected:

  private:
    void copy(const ISISLSPL2Packet& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ISISLSPL2Packet&);

  public:
    ISISLSPL2Packet(const char *name=NULL, int kind=0);
    ISISLSPL2Packet(const ISISLSPL2Packet& other);
    virtual ~ISISLSPL2Packet();
    ISISLSPL2Packet& operator=(const ISISLSPL2Packet& other);
    virtual ISISLSPL2Packet *dup() const {return new ISISLSPL2Packet(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, ISISLSPL2Packet& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, ISISLSPL2Packet& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>ansa/isis/ISISMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet ISISCSNPL1Packet extends ISISMessage
 * {
 * 	type = L1_CSNP;
 * 	unsigned short pduLength;						
 * 	unsigned char sourceID[7];						
 * 	unsigned char startLspID[8];					
 * 	unsigned char endLspID[8];						
 * 	TLV_t TLV[];									
 * }
 * </pre>
 */
class ISISCSNPL1Packet : public ::ISISMessage
{
  protected:
    unsigned short pduLength_var;
    unsigned char sourceID_var[7];
    unsigned char startLspID_var[8];
    unsigned char endLspID_var[8];
    TLV_t *TLV_var; // array ptr
    unsigned int TLV_arraysize;

  private:
    void copy(const ISISCSNPL1Packet& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ISISCSNPL1Packet&);

  public:
    ISISCSNPL1Packet(const char *name=NULL, int kind=0);
    ISISCSNPL1Packet(const ISISCSNPL1Packet& other);
    virtual ~ISISCSNPL1Packet();
    ISISCSNPL1Packet& operator=(const ISISCSNPL1Packet& other);
    virtual ISISCSNPL1Packet *dup() const {return new ISISCSNPL1Packet(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned short getPduLength() const;
    virtual void setPduLength(unsigned short pduLength);
    virtual unsigned int getSourceIDArraySize() const;
    virtual unsigned char getSourceID(unsigned int k) const;
    virtual void setSourceID(unsigned int k, unsigned char sourceID);
    virtual unsigned int getStartLspIDArraySize() const;
    virtual unsigned char getStartLspID(unsigned int k) const;
    virtual void setStartLspID(unsigned int k, unsigned char startLspID);
    virtual unsigned int getEndLspIDArraySize() const;
    virtual unsigned char getEndLspID(unsigned int k) const;
    virtual void setEndLspID(unsigned int k, unsigned char endLspID);
    virtual void setTLVArraySize(unsigned int size);
    virtual unsigned int getTLVArraySize() const;
    virtual TLV_t& getTLV(unsigned int k);
    virtual const TLV_t& getTLV(unsigned int k) const {return const_cast<ISISCSNPL1Packet*>(this)->getTLV(k);}
    virtual void setTLV(unsigned int k, const TLV_t& TLV);
};

inline void doPacking(cCommBuffer *b, ISISCSNPL1Packet& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, ISISCSNPL1Packet& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>ansa/isis/ISISMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet ISISCSNPL2Packet extends ISISCSNPL1Packet
 * {
 * 	type = L2_CSNP;
 * }
 * </pre>
 */
class ISISCSNPL2Packet : public ::ISISCSNPL1Packet
{
  protected:

  private:
    void copy(const ISISCSNPL2Packet& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ISISCSNPL2Packet&);

  public:
    ISISCSNPL2Packet(const char *name=NULL, int kind=0);
    ISISCSNPL2Packet(const ISISCSNPL2Packet& other);
    virtual ~ISISCSNPL2Packet();
    ISISCSNPL2Packet& operator=(const ISISCSNPL2Packet& other);
    virtual ISISCSNPL2Packet *dup() const {return new ISISCSNPL2Packet(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, ISISCSNPL2Packet& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, ISISCSNPL2Packet& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>ansa/isis/ISISMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet ISISPSNPL1Packet extends ISISMessage
 * {
 * 	type = L1_PSNP;
 * 	unsigned short pduLength;						
 * 	unsigned char sourceID[7];						
 * 	TLV_t TLV[];									
 * }
 * </pre>
 */
class ISISPSNPL1Packet : public ::ISISMessage
{
  protected:
    unsigned short pduLength_var;
    unsigned char sourceID_var[7];
    TLV_t *TLV_var; // array ptr
    unsigned int TLV_arraysize;

  private:
    void copy(const ISISPSNPL1Packet& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ISISPSNPL1Packet&);

  public:
    ISISPSNPL1Packet(const char *name=NULL, int kind=0);
    ISISPSNPL1Packet(const ISISPSNPL1Packet& other);
    virtual ~ISISPSNPL1Packet();
    ISISPSNPL1Packet& operator=(const ISISPSNPL1Packet& other);
    virtual ISISPSNPL1Packet *dup() const {return new ISISPSNPL1Packet(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned short getPduLength() const;
    virtual void setPduLength(unsigned short pduLength);
    virtual unsigned int getSourceIDArraySize() const;
    virtual unsigned char getSourceID(unsigned int k) const;
    virtual void setSourceID(unsigned int k, unsigned char sourceID);
    virtual void setTLVArraySize(unsigned int size);
    virtual unsigned int getTLVArraySize() const;
    virtual TLV_t& getTLV(unsigned int k);
    virtual const TLV_t& getTLV(unsigned int k) const {return const_cast<ISISPSNPL1Packet*>(this)->getTLV(k);}
    virtual void setTLV(unsigned int k, const TLV_t& TLV);
};

inline void doPacking(cCommBuffer *b, ISISPSNPL1Packet& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, ISISPSNPL1Packet& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>ansa/isis/ISISMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet ISISPSNPL2Packet extends ISISPSNPL1Packet
 * {
 * 	type = L2_PSNP;
 * }
 * </pre>
 */
class ISISPSNPL2Packet : public ::ISISPSNPL1Packet
{
  protected:

  private:
    void copy(const ISISPSNPL2Packet& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ISISPSNPL2Packet&);

  public:
    ISISPSNPL2Packet(const char *name=NULL, int kind=0);
    ISISPSNPL2Packet(const ISISPSNPL2Packet& other);
    virtual ~ISISPSNPL2Packet();
    ISISPSNPL2Packet& operator=(const ISISPSNPL2Packet& other);
    virtual ISISPSNPL2Packet *dup() const {return new ISISPSNPL2Packet(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, ISISPSNPL2Packet& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, ISISPSNPL2Packet& obj) {obj.parsimUnpack(b);}


#endif // _ISISMESSAGE_M_H_
